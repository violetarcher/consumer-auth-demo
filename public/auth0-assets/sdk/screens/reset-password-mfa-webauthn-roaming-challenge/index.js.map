{"version":3,"file":"index.js","sources":["../../../../src/screens/reset-password-mfa-webauthn-roaming-challenge/index.ts"],"sourcesContent":["import { ScreenIds, FormActions, Errors } from '../../constants';\nimport { BaseContext } from '../../models/base-context';\nimport { FormHandler } from '../../utils/form-handler';\nimport { getPasskeyCredentials } from '../../utils/passkeys';\n\nimport { ScreenOverride } from './screen-override';\n\nimport type {CustomOptions, WebAuthnErrorDetails } from '../../../interfaces/common';\nimport type { ScreenContext } from '../../../interfaces/models/screen';\nimport type {\n  ResetPasswordMfaWebAuthnRoamingChallengeMembers,\n  ScreenMembersOnResetPasswordMfaWebAuthnRoamingChallenge as ScreenOptions,\n  UseSecurityKeyOptions,\n  ShowErrorOptions,\n  TryAnotherMethodOptions,\n} from '../../../interfaces/screens/reset-password-mfa-webauthn-roaming-challenge';\nimport type { FormOptions as SDKFormOptions } from '../../../interfaces/utils/form-handler';\nimport type { PasskeyCredentialResponse } from '../../../interfaces/utils/passkeys';\n\n/**\n * @class ResetPasswordMfaWebAuthnRoamingChallenge\n * @extends BaseContext\n * implements ResetPasswordMfaWebAuthnRoamingChallengeMembers\n * description Manages interactions for the 'reset-password-mfa-webauthn-roaming-challenge' screen.\n * This screen prompts the user to use their WebAuthn roaming authenticator (e.g., a security key)\n * as a second factor during the password reset process. It handles:\n * - Initiating the security key challenge via the WebAuthn API.\n * - Submitting the successful credential assertion to Auth0.\n * - Reporting client-side WebAuthn API errors to Auth0.\n * - Allowing the user to try a different MFA method.\n */\nexport default class ResetPasswordMfaWebAuthnRoamingChallenge\n  extends BaseContext\n  implements ResetPasswordMfaWebAuthnRoamingChallengeMembers {\n  /**\n   * The unique identifier for this screen, used for internal SDK logic and telemetry.\n   * @type {string}\n   * static\n   * @readonly\n   */\n  static screenIdentifier: string = ScreenIds.RESET_PASSWORD_MFA_WEBAUTHN_ROAMING_CHALLENGE;\n\n  /**\n   * Holds the specific screen data and properties for this screen,\n   \n   * (for the WebAuthn challenge) and `showRememberDevice`.\n   * @type {ScreenOptions}\n   * @public\n   */\n  public screen: ScreenOptions;\n\n  /**\n   * Initializes a new instance of the `ResetPasswordMfaWebAuthnRoamingChallenge` class.\n   * It retrieves the necessary context (screen, transaction, etc.) from the global\n   * @throws {Error} If the Universal Login Context is not available or if the screen name\n   * in the context does not match `ResetPasswordMfaWebAuthnRoamingChallenge.screenIdentifier`.\n   */\n  constructor() {\n    super();\n    const screenContext = this.getContext('screen') as ScreenContext;\n    this.screen = new ScreenOverride(screenContext);\n  }\n\n  /**\n   * Initiates the WebAuthn security key challenge.\n   * This method internally calls `navigator.credentials.get()` using the challenge\n   * options provided in `this.screen.publicKey`.\n   * If the user successfully authenticates with their security key, the resulting\n   * `PublicKeyCredential` is stringified and submitted to Auth0 with `action: \"default\"`.\n   *\n   * @param {UseSecurityKeyOptions} [options] - Optional parameters for the operation.\n   * This can include `rememberDevice` (if `this.screen.showRememberDevice` is true) and\n   * any other custom key-value pairs to be sent in the form submission.\n   * The `response` field (the WebAuthn credential) is handled internally by this method.\n   * @returns {Promise<void>} A promise that resolves when the verification attempt is submitted.\n   * A successful operation usually results in Auth0 redirecting the user.\n   * @throws {Error} Throws an error if `this.screen.publicKey` is missing (indicating missing challenge options),\n   * if `getPasskeyCredentials` (which wraps `navigator.credentials.get()`) fails (e.g., user cancellation,\n   * no authenticator found, hardware error), or if the final form submission to Auth0 fails.\n   * It is crucial to catch errors from this method. WebAuthn API errors (like `NotAllowedError`)\n   * should be reported using {@link showError}.\n   *\n   * @example\n   * ```typescript\n   * // In your UI component for the reset-password-mfa-webauthn-roaming-challenge screen:\n   * const sdk = new ResetPasswordMfaWebAuthnRoamingChallenge();\n   *\n   * async function handleSecurityKeyAuth() {\n   *   try {\n   *     const userWantsToRemember = document.getElementById('remember-device-checkbox')?.checked || false;\n   *     await sdk.useSecurityKey({ rememberDevice: sdk.screen.showRememberDevice && userWantsToRemember });\n   *     // On success, Auth0 typically handles redirection.\n   *   } catch (err) {\n   *     console.error(\"Security key authentication failed:\", err);\n   *     // If it's a WebAuthn API error, report it to Auth0\n   *     if (err.name && err.message) { // Basic check for DOMException-like error\n   *       try {\n   *         await sdk.showError({ error: { name: err.name, message: err.message } });\n   *       } catch (reportError) {\n   *         console.error(\"Failed to report WebAuthn error:\", reportError);\n   *       }\n   *     }\n   *     // Update UI to inform the user, e.g., \"Security key verification failed. Please try again.\"\n   *     // Also check `sdk.transaction.errors` if the page might have reloaded with an error message from the server.\n   *   }\n   * }\n   * ```\n   */\n  public async useSecurityKey(options?: UseSecurityKeyOptions): Promise<void> {\n    const publicKeyOpts = this.screen.publicKey;\n    \n    if (!publicKeyOpts) {\n      throw new Error(Errors.PASSKEY_PUBLIC_KEY_UNAVAILABLE);\n    }\n\n    // `getPasskeyCredentials` calls `navigator.credentials.get()` and processes the response.\n    // It will throw if `navigator.credentials.get()` fails or returns null.\n\n    const credential = (await getPasskeyCredentials(publicKeyOpts)) as PasskeyCredentialResponse | null;\n\n    if (!credential) {\n      // This case should ideally be caught by getPasskeyCredentials throwing an error\n      throw new Error(Errors.PASSKEY_CREDENTIALS_UNAVAILABLE);\n    }\n\n    const formOptions: SDKFormOptions = {\n      state: this.transaction.state,\n      telemetry: [ResetPasswordMfaWebAuthnRoamingChallenge.screenIdentifier, 'useSecurityKey'],\n      route: '/u/mfa-webauthn-challenge', // As per OpenAPI spec\n    };\n\n    const { rememberDevice, ...customSubmissionOptions } = options || {};\n    const payloadToSubmit: CustomOptions = {\n      ...customSubmissionOptions,\n      action: FormActions.DEFAULT,\n      response: JSON.stringify(credential),\n    };\n\n    if (this.screen.showRememberDevice && rememberDevice) {\n      payloadToSubmit.rememberBrowser = true;\n    }\n\n    await new FormHandler(formOptions).submitData(payloadToSubmit);\n  }\n\n  /**\n   * Reports a client-side WebAuthn API error (from `navigator.credentials.get()`) to Auth0.\n   * This method is intended to be called when {@link useSecurityKey} (or a direct call to\n   * `navigator.credentials.get()`) fails due to a standard WebAuthn API error\n   * (e.g., `NotAllowedError` if the user cancels, `NotFoundError`, `SecurityError`, timeout).\n   * It submits the error details with `action: \"showError::{errorDetailsJsonString}\"` and an empty `response`.\n   *\n   * @param {ShowErrorOptions} options - Contains the `error` object (with `name` and `message`\n   * from the WebAuthn API DOMException), an optional `rememberDevice` flag, and any other custom options.\n   * @returns {Promise<void>} A promise that resolves when the error report is successfully submitted.\n   * Auth0 may re-render the page with specific error messages in `this.transaction.errors` or redirect.\n   * @throws {Error} Throws an error if the form submission itself fails (e.g., network error, invalid state).\n   *\n   * @example\n   * ```typescript\n   * // In your UI, after catching an error from `sdk.useSecurityKey()` or `navigator.credentials.get()`:\n   * if (webAuthnError instanceof DOMException) {\n   *   await sdk.showError({\n   *     error: { name: webAuthnError.name, message: webAuthnError.message },\n   *     rememberDevice: userWantsToRemember // if applicable\n   *   });\n   * }\n   * ```\n   */\n  public async showError(options: ShowErrorOptions): Promise<void> {\n    const { error, rememberDevice, ...customPayload } = options;\n\n    const formOptions: SDKFormOptions = {\n      state: this.transaction.state,\n      telemetry: [ResetPasswordMfaWebAuthnRoamingChallenge.screenIdentifier, 'showError'],\n      route: '/u/mfa-webauthn-challenge', // As per OpenAPI spec\n    };\n\n    // Sanitize errorDetails for payload, including only defined properties\n    const errorDetailsForPayload: Partial<WebAuthnErrorDetails> = { name: error.name, message: error.message };\n    if (error.code !== undefined) errorDetailsForPayload.code = error.code;\n    // Add other common DOMException properties if needed and part of WebAuthnErrorDetails\n    // if (error.type !== undefined) errorDetailsForPayload.type = error.type; // Example if 'type' was added\n\n    const errorDetailsString = JSON.stringify(errorDetailsForPayload);\n\n    const payloadToSubmit: { action: string; response: string; rememberBrowser?: boolean;[key: string]: unknown } = {\n      ...customPayload,\n      action: `${FormActions.SHOW_ERROR_ACTION_PREFIX}${errorDetailsString}`,\n      response: '', // Response is empty for showError actions\n    };\n\n    if (this.screen.showRememberDevice && rememberDevice) {\n      payloadToSubmit.rememberBrowser = true;\n    }\n\n    await new FormHandler(formOptions).submitData(payloadToSubmit);\n  }\n\n  /**\n   * Allows the user to opt-out of the WebAuthn roaming authenticator challenge and select a different MFA method.\n   * This action submits `action: \"pick-authenticator\"` to Auth0, which should navigate\n   * the user to an MFA factor selection screen.\n   *\n   * @param {TryAnotherMethodOptions} [options] - Optional. Parameters for the operation,\n   * such as `rememberDevice` (if `this.screen.showRememberDevice` is true) and other custom options.\n   * @returns {Promise<void>} A promise that resolves when the 'pick-authenticator' action is submitted.\n   * @throws {Error} Throws an error if the form submission fails (e.g., network error, invalid state).\n   *\n   * @example\n   * ```typescript\n   * // When the user clicks a \"Try Another Way\" button:\n   * await sdk.tryAnotherMethod({ rememberDevice: userWantsToRemember });\n   * // Auth0 handles redirection to the MFA selection screen.\n   * ```\n   */\n  public async tryAnotherMethod(options?: TryAnotherMethodOptions): Promise<void> {\n    const formOptions: SDKFormOptions = {\n      state: this.transaction.state,\n      telemetry: [ResetPasswordMfaWebAuthnRoamingChallenge.screenIdentifier, 'tryAnotherMethod'],\n      route: '/u/mfa-webauthn-challenge', // As per OpenAPI spec\n    };\n\n    const { rememberDevice, ...customPayload } = options || {};\n    const payloadToSubmit: { action: string; rememberBrowser?: boolean;[key: string]: unknown } = {\n      ...customPayload,\n      action: FormActions.PICK_AUTHENTICATOR,\n    };\n\n    if (this.screen.showRememberDevice && rememberDevice) {\n      payloadToSubmit.rememberBrowser = true;\n    }\n\n    await new FormHandler(formOptions).submitData(payloadToSubmit);\n  }\n}\n\n// Export all necessary types and members for this screen\nexport {\n  ResetPasswordMfaWebAuthnRoamingChallengeMembers,\n  ScreenOptions as ScreenMembersOnResetPasswordMfaWebAuthnRoamingChallenge,\n  UseSecurityKeyOptions,\n  ShowErrorOptions,\n  TryAnotherMethodOptions,\n  WebAuthnErrorDetails,\n  PasskeyCredentialResponse,\n};\nexport * from '../../../interfaces/export/common';\nexport * from '../../../interfaces/export/base-properties';"],"names":["ResetPasswordMfaWebAuthnRoamingChallenge","BaseContext","static","ScreenIds","RESET_PASSWORD_MFA_WEBAUTHN_ROAMING_CHALLENGE","screen","constructor","super","screenContext","this","getContext","ScreenOverride","useSecurityKey","options","publicKeyOpts","publicKey","Error","Errors","PASSKEY_PUBLIC_KEY_UNAVAILABLE","credential","getPasskeyCredentials","PASSKEY_CREDENTIALS_UNAVAILABLE","formOptions","state","transaction","telemetry","screenIdentifier","route","rememberDevice","customSubmissionOptions","payloadToSubmit","action","FormActions","DEFAULT","response","JSON","stringify","showRememberDevice","rememberBrowser","FormHandler","submitData","showError","error","customPayload","errorDetailsForPayload","name","message","undefined","code","errorDetailsString","SHOW_ERROR_ACTION_PREFIX","tryAnotherMethod","PICK_AUTHENTICATOR"],"mappings":"iZA+BqB,MAAAA,UACXC,EAQRC,wBAAkCC,EAAUC,8CASrCC,OAQP,WAAAC,GACEC,QACA,MAAMC,EAAgBC,KAAKC,WAAW,UACtCD,KAAKJ,OAAS,IAAIM,EAAeH,GAgD5B,oBAAMI,CAAeC,GAC1B,MAAMC,EAAgBL,KAAKJ,OAAOU,UAElC,IAAKD,EACH,MAAM,IAAIE,MAAMC,EAAOC,gCAMzB,MAAMC,QAAoBC,EAAsBN,GAEhD,IAAKK,EAEH,MAAM,IAAIH,MAAMC,EAAOI,iCAGzB,MAAMC,EAA8B,CAClCC,MAAOd,KAAKe,YAAYD,MACxBE,UAAW,CAACzB,EAAyC0B,iBAAkB,kBACvEC,MAAO,8BAGHC,eAAEA,KAAmBC,GAA4BhB,GAAW,CAAE,EAC9DiB,EAAiC,IAClCD,EACHE,OAAQC,EAAYC,QACpBC,SAAUC,KAAKC,UAAUjB,IAGvBV,KAAKJ,OAAOgC,oBAAsBT,IACpCE,EAAgBQ,iBAAkB,SAG9B,IAAIC,EAAYjB,GAAakB,WAAWV,GA2BzC,eAAMW,CAAU5B,GACrB,MAAM6B,MAAEA,EAAKd,eAAEA,KAAmBe,GAAkB9B,EAE9CS,EAA8B,CAClCC,MAAOd,KAAKe,YAAYD,MACxBE,UAAW,CAACzB,EAAyC0B,iBAAkB,aACvEC,MAAO,6BAIHiB,EAAwD,CAAEC,KAAMH,EAAMG,KAAMC,QAASJ,EAAMI,cAC9EC,IAAfL,EAAMM,OAAoBJ,EAAuBI,KAAON,EAAMM,MAIlE,MAAMC,EAAqBd,KAAKC,UAAUQ,GAEpCd,EAA0G,IAC3Ga,EACHZ,OAAQ,GAAGC,EAAYkB,2BAA2BD,IAClDf,SAAU,IAGRzB,KAAKJ,OAAOgC,oBAAsBT,IACpCE,EAAgBQ,iBAAkB,SAG9B,IAAIC,EAAYjB,GAAakB,WAAWV,GAoBzC,sBAAMqB,CAAiBtC,GAC5B,MAAMS,EAA8B,CAClCC,MAAOd,KAAKe,YAAYD,MACxBE,UAAW,CAACzB,EAAyC0B,iBAAkB,oBACvEC,MAAO,8BAGHC,eAAEA,KAAmBe,GAAkB9B,GAAW,CAAE,EACpDiB,EAAwF,IACzFa,EACHZ,OAAQC,EAAYoB,oBAGlB3C,KAAKJ,OAAOgC,oBAAsBT,IACpCE,EAAgBQ,iBAAkB,SAG9B,IAAIC,EAAYjB,GAAakB,WAAWV"}