import{FormActions as e}from"../../constants/form-actions.js";import{ScreenIds as t}from"../../constants/enums.js";import{Errors as r}from"../../constants/errors.js";import{BaseContext as s}from"../../models/base-context.js";import{FormHandler as n}from"../../utils/form-handler.js";import{getPasskeyCredentials as o}from"../../utils/passkeys.js";import{ScreenOverride as a}from"./screen-override.js";class i extends s{static screenIdentifier=t.MFA_WEBAUTHN_ROAMING_CHALLENGE;screen;constructor(){super();const e=this.getContext("screen");this.screen=new a(e)}async verify(t){const s=this.screen.publicKey;if(!s)throw new Error(r.PASSKEY_PUBLIC_KEY_UNAVAILABLE);const a=await o(s);if(!a)throw new Error(r.PASSKEY_CREDENTIALS_UNAVAILABLE);const c={state:this.transaction.state,telemetry:[i.screenIdentifier,"verify"],route:"/u/mfa-webauthn-challenge"},{rememberDevice:m,...f}=t||{},h={...f,action:e.DEFAULT,response:JSON.stringify(a)};m&&this.screen.data?.showRememberDevice&&(h.rememberBrowser=!0),await new n(c).submitData(h)}async reportWebAuthnError(t){const{error:r,...s}=t,o={state:this.transaction.state,telemetry:[i.screenIdentifier,"reportWebAuthnError"],route:"/u/mfa-webauthn-challenge"},a={name:r.name,message:r.message};void 0!==r.code&&(a.code=r.code),void 0!==r.type&&(a.type=r.type);const c=JSON.stringify(a);await new n(o).submitData({...s,action:`${e.SHOW_ERROR_ACTION_PREFIX}${c}`,response:""})}async tryAnotherMethod(t){const r={state:this.transaction.state,telemetry:[i.screenIdentifier,"tryAnotherMethod"],route:"/u/mfa-webauthn-challenge"};await new n(r).submitData({...t||{},action:e.PICK_AUTHENTICATOR})}}export{i as default};
//# sourceMappingURL=index.js.map
