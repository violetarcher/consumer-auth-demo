{"version":3,"file":"index.js","sources":["../../../../src/screens/mfa-webauthn-roaming-challenge/index.ts"],"sourcesContent":["import { ScreenIds, FormActions, Errors } from '../../constants';\nimport { BaseContext } from '../../models/base-context';\nimport { FormHandler } from '../../utils/form-handler';\nimport { getPasskeyCredentials } from '../../utils/passkeys';\n\nimport { ScreenOverride } from './screen-override';\n\nimport type { CustomOptions, WebAuthnErrorDetails } from '../../../interfaces/common';\nimport type { ScreenContext } from '../../../interfaces/models/screen';\nimport type {\n  MfaWebAuthnRoamingChallengeMembers,\n  ScreenMembersOnMfaWebAuthnRoamingChallenge as ScreenOptions,\n  VerifySecurityKeyOptions,\n  ReportWebAuthnErrorOptions,\n  TryAnotherMethodOptions\n} from '../../../interfaces/screens/mfa-webauthn-roaming-challenge';\nimport type { FormOptions as SDKFormOptions } from '../../../interfaces/utils/form-handler';\n\n/**\n * @class MfaWebAuthnRoamingChallenge\n * @extends BaseContext\n * implements MfaWebAuthnRoamingChallengeMembers\n * description Manages interactions for the MFA WebAuthn Roaming Challenge screen.\n * This screen prompts the user to use their security key (roaming authenticator) to verify their identity.\n * It handles the WebAuthn `navigator.credentials.get()` API call, submission of the resulting credential,\n * provides a method for explicitly reporting browser-side WebAuthn errors, and offers an option\n * to try a different MFA method.\n */\nexport default class MfaWebAuthnRoamingChallenge extends BaseContext implements MfaWebAuthnRoamingChallengeMembers {\n  /**\n   * static\n   * @property {string} screenIdentifier - The unique identifier for the 'mfa-webauthn-roaming-challenge' screen.\n   */\n  static screenIdentifier: string = ScreenIds.MFA_WEBAUTHN_ROAMING_CHALLENGE;\n\n  /**\n   * @property {ScreenOptions} screen - Holds the specific screen data and properties,\n   * processed by `ScreenOverride`. This includes `publicKeyChallengeOptions` for the WebAuthn API call.\n   */\n  public screen: ScreenOptions;\n\n  /**\n   * Initializes a new instance of the `MfaWebAuthnRoamingChallenge` class.\n   * @throws {Error} If the Universal Login Context is not available or if the screen name\n   * in the context does not match `MfaWebAuthnRoamingChallenge.screenIdentifier`.\n   */\n  constructor() {\n    super();\n    const screenContext = this.getContext('screen') as ScreenContext;\n    this.screen = new ScreenOverride(screenContext);\n  }\n\n  async verify(options?: VerifySecurityKeyOptions): Promise<void> {\n    const publicKeyOpts = this.screen.publicKey;\n    if (!publicKeyOpts) {\n      throw new Error(Errors.PASSKEY_PUBLIC_KEY_UNAVAILABLE);\n    }\n\n    // getPasskeyCredentials will call navigator.credentials.get() and re-throw if it fails.\n    const credential = await getPasskeyCredentials(publicKeyOpts);\n\n    // If credential is null (though getPasskeyCredentials should throw if it fails to get one)\n    if (!credential) {\n      throw new Error(Errors.PASSKEY_CREDENTIALS_UNAVAILABLE);\n    }\n\n    const formOptions: SDKFormOptions = {\n      state: this.transaction.state,\n      telemetry: [MfaWebAuthnRoamingChallenge.screenIdentifier, 'verify'],\n      route: '/u/mfa-webauthn-challenge',\n    };\n\n    const { rememberDevice, ...customSubmissionOptions } = options || {};\n\n    const payloadToSubmit: CustomOptions = {\n      ...customSubmissionOptions, // Spread any other custom options from the VerifySecurityKeyOptions\n      action: FormActions.DEFAULT,\n      response: JSON.stringify(credential),\n    };\n\n    if (rememberDevice && this.screen.data?.showRememberDevice) {\n      payloadToSubmit.rememberBrowser = true;\n    }\n\n    await new FormHandler(formOptions).submitData(payloadToSubmit);\n  }\n\n  async reportWebAuthnError(options: ReportWebAuthnErrorOptions): Promise<void> {\n    const { error, ...customPayload } = options; // Separate the 'error' object from other custom options\n\n    const formOptions: SDKFormOptions = {\n      state: this.transaction.state,\n      telemetry: [MfaWebAuthnRoamingChallenge.screenIdentifier, 'reportWebAuthnError'],\n      route: '/u/mfa-webauthn-challenge',\n    };\n\n    // Construct the error details object carefully, only including defined properties from the input 'error'\n    const errorDetailsForPayload: Partial<WebAuthnErrorDetails> = { name: error.name, message: error.message };\n    if (error.code !== undefined) errorDetailsForPayload.code = error.code;\n    if (error.type !== undefined) errorDetailsForPayload.type = error.type;\n    const errorDetailsString = JSON.stringify(errorDetailsForPayload);\n\n    await new FormHandler(formOptions).submitData({\n      ...customPayload, // Spread any other custom key-value pairs from the 'options' object\n      action: `${FormActions.SHOW_ERROR_ACTION_PREFIX}${errorDetailsString}`,\n      response: '', // Response is typically empty when the action is showError, as per OpenAPI examples\n    });\n  }\n\n  async tryAnotherMethod(options?: TryAnotherMethodOptions): Promise<void> {\n    const formOptions: SDKFormOptions = {\n      state: this.transaction.state,\n      telemetry: [MfaWebAuthnRoamingChallenge.screenIdentifier, 'tryAnotherMethod'],\n      route: '/u/mfa-webauthn-challenge',\n    };\n\n    await new FormHandler(formOptions).submitData({\n      ...(options || {}), // Spread all properties from the options object as custom parameters\n      action: FormActions.PICK_AUTHENTICATOR,\n    });\n  }\n}\n\n// Export the primary class and its relevant member and options interfaces.\nexport {\n  MfaWebAuthnRoamingChallengeMembers,\n  ScreenOptions as ScreenMembersOnMfaWebAuthnRoamingChallenge,\n  VerifySecurityKeyOptions,\n  ReportWebAuthnErrorOptions,\n  TryAnotherMethodOptions,\n  WebAuthnErrorDetails,\n};\n\n// Re-export common interfaces and base properties for convenience.\nexport * from '../../../interfaces/export/common';\nexport * from '../../../interfaces/export/base-properties';"],"names":["MfaWebAuthnRoamingChallenge","BaseContext","static","ScreenIds","MFA_WEBAUTHN_ROAMING_CHALLENGE","screen","constructor","super","screenContext","this","getContext","ScreenOverride","verify","options","publicKeyOpts","publicKey","Error","Errors","PASSKEY_PUBLIC_KEY_UNAVAILABLE","credential","getPasskeyCredentials","PASSKEY_CREDENTIALS_UNAVAILABLE","formOptions","state","transaction","telemetry","screenIdentifier","route","rememberDevice","customSubmissionOptions","payloadToSubmit","action","FormActions","DEFAULT","response","JSON","stringify","data","showRememberDevice","rememberBrowser","FormHandler","submitData","reportWebAuthnError","error","customPayload","errorDetailsForPayload","name","message","undefined","code","type","errorDetailsString","SHOW_ERROR_ACTION_PREFIX","tryAnotherMethod","PICK_AUTHENTICATOR"],"mappings":"iZA4BqB,MAAAA,UAAoCC,EAKvDC,wBAAkCC,EAAUC,+BAMrCC,OAOP,WAAAC,GACEC,QACA,MAAMC,EAAgBC,KAAKC,WAAW,UACtCD,KAAKJ,OAAS,IAAIM,EAAeH,GAGnC,YAAMI,CAAOC,GACX,MAAMC,EAAgBL,KAAKJ,OAAOU,UAClC,IAAKD,EACH,MAAM,IAAIE,MAAMC,EAAOC,gCAIzB,MAAMC,QAAmBC,EAAsBN,GAG/C,IAAKK,EACH,MAAM,IAAIH,MAAMC,EAAOI,iCAGzB,MAAMC,EAA8B,CAClCC,MAAOd,KAAKe,YAAYD,MACxBE,UAAW,CAACzB,EAA4B0B,iBAAkB,UAC1DC,MAAO,8BAGHC,eAAEA,KAAmBC,GAA4BhB,GAAW,CAAE,EAE9DiB,EAAiC,IAClCD,EACHE,OAAQC,EAAYC,QACpBC,SAAUC,KAAKC,UAAUjB,IAGvBS,GAAkBnB,KAAKJ,OAAOgC,MAAMC,qBACtCR,EAAgBS,iBAAkB,SAG9B,IAAIC,EAAYlB,GAAamB,WAAWX,GAGhD,yBAAMY,CAAoB7B,GACxB,MAAM8B,MAAEA,KAAUC,GAAkB/B,EAE9BS,EAA8B,CAClCC,MAAOd,KAAKe,YAAYD,MACxBE,UAAW,CAACzB,EAA4B0B,iBAAkB,uBAC1DC,MAAO,6BAIHkB,EAAwD,CAAEC,KAAMH,EAAMG,KAAMC,QAASJ,EAAMI,cAC9EC,IAAfL,EAAMM,OAAoBJ,EAAuBI,KAAON,EAAMM,WAC/CD,IAAfL,EAAMO,OAAoBL,EAAuBK,KAAOP,EAAMO,MAClE,MAAMC,EAAqBhB,KAAKC,UAAUS,SAEpC,IAAIL,EAAYlB,GAAamB,WAAW,IACzCG,EACHb,OAAQ,GAAGC,EAAYoB,2BAA2BD,IAClDjB,SAAU,KAId,sBAAMmB,CAAiBxC,GACrB,MAAMS,EAA8B,CAClCC,MAAOd,KAAKe,YAAYD,MACxBE,UAAW,CAACzB,EAA4B0B,iBAAkB,oBAC1DC,MAAO,mCAGH,IAAIa,EAAYlB,GAAamB,WAAW,IACxC5B,GAAW,CAAA,EACfkB,OAAQC,EAAYsB"}