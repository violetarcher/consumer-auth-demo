import{FormActions as e}from"../../constants/form-actions.js";import{ScreenIds as t}from"../../constants/enums.js";import{Errors as r}from"../../constants/errors.js";import{BaseContext as s}from"../../models/base-context.js";import{FormHandler as o}from"../../utils/form-handler.js";import{getPasskeyCredentials as n}from"../../utils/passkeys.js";import{ScreenOverride as a}from"./screen-override.js";class i extends s{static screenIdentifier=t.RESET_PASSWORD_MFA_WEBAUTHN_PLATFORM_CHALLENGE;screen;constructor(){super();const e=this.getContext("screen");this.screen=new a(e)}async continueWithPasskey(t){const s=this.screen.publicKey;if(!s)throw new Error(r.PASSKEY_PUBLIC_KEY_UNAVAILABLE);const a=await n(s);if(!a)throw new Error(r.PASSKEY_CREDENTIALS_UNAVAILABLE);const c={state:this.transaction.state,telemetry:[i.screenIdentifier,"continueWithPasskey"],route:"/u/mfa-webauthn-platform-challenge"},{rememberDevice:m,...f}=t||{},h={...f,action:e.DEFAULT,response:JSON.stringify(a)};this.screen.showRememberDevice&&m&&(h.rememberBrowser="true"),await new o(c).submitData(h)}async reportBrowserError(t){if(!t||!t.error||"string"!=typeof t.error.name||"string"!=typeof t.error.message)throw new Error("The `error` property in options, with `name` and `message` strings, is required.");const{error:r,...s}=t,n={state:this.transaction.state,telemetry:[i.screenIdentifier,"reportBrowserError"],route:"/u/mfa-webauthn-platform-challenge"},a=JSON.stringify(r),c={...s,action:`${e.SHOW_ERROR_ACTION_PREFIX}${a}`,response:""};await new o(n).submitData(c)}async tryAnotherMethod(t){const r={state:this.transaction.state,telemetry:[i.screenIdentifier,"tryAnotherMethod"],route:"/u/mfa-webauthn-platform-challenge"},s={...t||{},action:e.PICK_AUTHENTICATOR};await new o(r).submitData(s)}}export{i as default};
//# sourceMappingURL=index.js.map
